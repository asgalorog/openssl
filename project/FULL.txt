Задача:


В головной директории проекта должен располагаться Makefile, который
обеспечивает
следующую функциональность:

Вызов 'make' должен скачивать актуальную версию OpenSSL, собирать её с
необходимыми опциями,
а также собирать утилиту psec.bin. (Название подкорректируете по желанию).

Вызов 'make clean' должен очищать дерево сборки psec.bin, но не трогать
дерево сборки OpenSSL.

Вызовы 'make clean-all' или 'make dirclean' должны очищать все
сгенерированные файлы и
приводить локальную копию проекта в "чистое" состояние (как будто её
только что скачали из git).

Вызов 'make test' должен выполнять некий базовый тест, проверяющий
основную функциональность
утилиты psec.bin.

В головной директории должен лежать bash-скрипт psec, обеспечивающий
вызов утилиты psec.bin
с переменными окружения, необходимыми для корректной работы psec.bin.
В частности, должна быть установлена корректная LD_LIBRARY_PATH для
корректной динамической
линковки с собранной библиотекой OpenSSL, ибо линукс-системы содержат
свою собранную
версию OpenSSL, а мы должны цеплять свою. Все опции утилиты psec должны
один-в-один
передаваться утилите psec.bin.

Исходные тексты утилиты psec.bin должны быть написаны на языке Си или Си++
(сами выберете, что правильней и удобней).
Настоятельно НЕ рекомендуется использовать сторонние библиотеки (кроме
OpenSSL).
Также, если Вы выберите С++ и захотите использовать STL, то настоятельно
НЕ рекомендую
использовать iostream для консольного ввода, чтобы Вы смогли
прочувствовать низкоуровневую
работу с терминалом.


Вызов утилиты должен иметь формат:
psec.bin команда опции

Команды:

key - генерация закрытых ключей ГОСТ Р 34.10-2001.
cert - выпуск сертификатов X.509 с открытыми ключами ГОСТ Р 34.10-2001.
client - запуск psec.bin в режиме клиента и инициирование связи с сервером.
server - запуск psec.bin в режиме сервера и ожидание соединения от клиента.

(Как включать ГОСТ в OpenSSL написано в openssl/engines/ccgost/README.txt).

Опции:

Для команды key:

--key-params=0|A|B|C|XA|XB - указание набора криптопараметров ключевой
пары ГОСТ.
(0-тестовый набор, XA=XchA, XB=XchB).

--subject="CN=Субъект1,O=Хорошая организация,C=RU" - X500-имя субъекта,
для которого
генерируется закрытый ключ. Должны поддерживаться следующие атрибуты:
CN, S, G, E, SN, T, OU, O, street, L, ST, C.

--key-out=файл_сохраняемого_ключа

Файл закрытого ключа должен содержать DER-кодированную структуру ASN.1:

GostPrivateKey ::= SEQUENCE {
     subject Name, -- из RFC 5280
     algorithm AlgorithmIdentifier, -- из RFC 5280, 4357, 4490, 4491.
     privateKey OCTET STRING
}

Поле algorithm должно содержать идентификатор алгоритма открытого ключа
ГОСТ Р 34.10-2001
и идентификатор криптопараметров ключа (см. RFC 4357, 4490, 4491).


Для команды cert:

--issuer-key=файл_закрытого_ключа_издателя

--subject-key=файл_закрытого_ключа_субъекта (для корневых сертификатов
должно совпадать
с issuer-key).

--ca - если присутствует, то выпускается сертификат удостоверяющего
центра (взведённые
биты BasicConstraints/cA, KeyUsage/keyCertSign, KeyUsage/cRLSign).
Должно присутствовать
для корневых сертификатов).

--validity=срок_действия_сертификата_в_днях

--serial=серийный_номер (в удобном формате - 16-ричный или 10-чный).

--cert-out=файл_сохраняемого_сертификата

В расширении KeyUsage должны быть взведены биты digitalSignature,
nonRepudiation,
keyEncipherment, keyAgreement. На остальные расширения - забить.

Файл сертификата должен содержать DER-кодированную структуру Certificate
из RFC 5280.


Для команд client и server:

--ip=ip:port - адрес/порт сервера

--my-cert=файл - собственный сертификат

--my-key=файл - собственный закрытый ключ

--oppo-cert=файл - сертификат оппонента

--ca-cert=файл - сертификат удостоверяющего центра. Данная опция может
повторяться несколько
раз, если существуют промежуточные (некорневые) удостоверяющие центры.


Протокол клиента и сервера:

Клиент осуществляет соединение с сервером по протоколу TCP. Клиент и
сервер обмениваются
подписанными и зашифрованными DER-кодированными сообщениями CMS (см. RFC
5652, 4490, 4357).

Головная структура CMS-сообщения ContentInfo должна инкапсулировать
структуру SignedData,
которая в свою очередь должна инкапсулировать структуру EnvelopedData,
которая в свою
очередь должна инкапсулировать зашифрованную DER-кодированную структуру
PSecMessage (см. ниже).

SignedData должна содержать ЭЦП, выполненную на ключе отправителя.

EnvelopedData должна содержать инкапсулированные данные, зашифрованные
на ключе получателя.
Идентификатор инкапсулированных данных должен быть равен id-psec-message
(см. ниже).

Сертификаты в структурах SignedData и EnvelopedData пересылать не нужно
(ибо мы их явно
указываем в утилите).

Для шифрования EnvelopedData использовать механизм KeyTransport (см. RFC
4490).
(Впрочем функции CMS_ из OpenSSL его как раз и используют).

PSEC-MESSAGE-MODULE
DEFINITIONS IMPLICIT TAGS ::=
BEGIN

PSecMessage ::= PSecMessageTemplate{{PSecMessageTypes}}

PSecMessageTemplate { PSEC-MESSAGE-TYPE:ObjSet } :: = SEQUENCE {
     seqno INTEGER,
     mtype PSEC-MESSAGE-TYPE.&id({ObjSet}),
     mcontent PSEC-MESSAGE-TYPE.&Type({ObjSet} {@mtype})
}

PSEC-MESSAGE-TYPE ::= TYPE-IDENTIFIER

PSecMessageTypes ::= {
     { PSMCommand IDENTIFIED BY id-psm-command } |
     { PSMText IDENTIFIED BY id-psm-text } |
     { PSMFile IDENTIFIED BY id-psm-file }
}

id-papugin OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
dod(6) internet(1)
     private(4) enterprise(1) factor-ts(13312) room503(503)
podobaev-students(5)
     papugin(1) };
-- Я Вам выделил дерево OID-ов.

id-psec-message OBJECT IDENTIFIER ::= { id-papugin psec-message(1) }

id-psm-command OBJECT IDENTIFIER ::= { id-papugin psm-command(2) }

id-psm-text OBJECT IDENTIFIER ::= { id-papugin psm-text(3) }

id-psm-file OBJECT IDENTIFIER ::= { id-papugin psm-file(4) }

PSMCommand ::= SEQUENCE {
     command INTEGER { hello(0), goodbye(1), ack(2), ... },
     refseqno INTEGER OPTIONAL, -- используется только для ack
     text [0] PSMText OPTIONAL
}

PSMText ::= SEQUENCE OF UTF8String

PSMFile :: = SEQUENCE {
     name UTF8String,
     file OCTET STRING
}

END


Каждое сообщение должно иметь уникальный монотонно и последовательно
возрастающий seqno.
Для клиента и сервера seqno считаются независимо. Оппонент должен
проверять монотонность
(и непрерываемость) присланных seqno и в случае ошибки выводить уведомление.

После установления соединения клиент шлёт серверу PSMCommand/hello.
Сервер должен ответить PSMCommand/ack с refseqno, указывающим на
присланный hello.
После этого соединение считается установленным (аутентифицированным).

Далее клиент или сервер могут слать друг другу сообщения PSMText или
PSMFile.
После каждого сообщения узел должен ожидать от оппонента PSMCommand/ack
с соотв. refseqno.

Когда узел желает завершить соединение с оппонентом, он посылает
PSMCommand.goodbye и
дожидается соответствующего ack от оппонента. После этого оба закрывают
TCP-соединение.

Каждое сообщение, присланное от оппонента должно проверяться сначала на
ЭЦП, а потом
расшифровываться. Все присланные сертификаты должны проверяться до
корневого.
После запуска утилиты все указанные сертификаты должны быть проверены до
корневого.
(C CRL заморачиваться не будем).

Поле PSMCommand.text может содержать произвольный диагностический текст,
который должен
выводиться оппонентом на экран при получении команды.

В UTF8-строках допускаются печатаемые ASCII-символы (от 32 до 126) и
русские буквы.

При запуске утилиты psec в режиме client или server, она входит в
интерактивный режим.
Весь напечатанный текст должен передаваться оппоненту через PSMText.
Полученный текст должен выводиться оппонентом на экран.
Если в начале строки стоит конструкция:

file:имя_файла

то данный файл должен быть передан оппоненту через PSMFile. Оппонент
должен сохранить его
в текущей директории. Если такой файл уже существует, оппонент должен
добавить к имени
уникальный суффикс (.1, .2, ...).

Нажатие Ctrl-C в интерактивном режиме инициирует PSMCommand/goodbye.

Для удобства отладки рекомендуется выводить отладочные сообщения сеанса
в отдельный лог файл.

Если утилита вызывается с перенаправленным вводом (например, cat text |
./psec client ...),
то конец соединения должен инициироваться завершением потока (концом
файла text).
